---
title:  最小网元设计【阶段三】
date: 2020-02-02 11:23:19
tags:
	- 计算机网络
	- 网络编程
---
# 阶段三：共享


## 3.1 本阶段预期
二层交换机的实现，即按目的转发、反向地址学习以及未知广播。
实现交换机成环设计。

<!-- more -->

## 3.2 按目的转发
### 3.2.1 定义
二层交换机从某个端口收到帧后，通过查看到此帧的目的MAC地址，然后凭借MAC地址表向相应的端口转发。
### 3.2.2 方案
在交互设计基础上为每个帧添加源地址和目的地址
为网络中每个设备编址（根据设备号编址，例如设备6其MAC地址为6），为交换机编写代码实现MAC地址表（利用结构数组），每接收一帧，查看其目的MAC，先判断是否为自身，若是则解封处理递交上层，若不是则查表获得端口号转发，若查无此地址则广播到其他端口（直通转发）。
### 3.2.3 代码实现

```c
struct Switch_Table//建立MAC表
{
	int addr;
	int port;
};
Switch_Table* st = (Switch_Table*)malloc(15 * sizeof(Switch_Table));//实例化

char* add_code_source_node(char* p);//插入目的地址
int get_decode_source_node(char* s);//获得目的地址
void print_switch_table();//打印MAC表
int find_st_port(int addr);//根据目的地址查找端口号-

```
### 3.2.4 测试
- 发方将源地址、目的地址插入帧中发送
![按目的转发测试](https://img-blog.csdnimg.cn/20200202110449331.png)
- 交换机MAC表
![按目的转发测试](https://img-blog.csdnimg.cn/202002021105187.png)
- 查看目的地址，按目的查表转发
![按目的转发测试](https://img-blog.csdnimg.cn/20200202110551153.png)
## 3.3 反向地址学习
### 3.3.1 定义
在交换机初始化的时候，其MAC地址表是没有任何MAC地址和端口的映射条目的，通过查看帧源地址进行地址的学习，以此得到MAC表。
### 3.3.2 方案
在接收帧后，获取其源地址，查表，若表中无对应关系，则进行该地址的学习。
特别说明的是，反向地址学习一般流程是要先进行ARP广播对其所有端口所连设备进行反向地址学习的，笔者对此问题进行讨论认为，在规模较大，通信复杂的情况下，确实应该先进行广播学习，但若是规模小的通信系统，通信的设备不多的情况下，如若仍然先学习所有设备地址，则会造成信道资源的浪费，在本项目最终成果中，笔者让交换机只对所接收帧内的源地址进行学习（按需学习），对于没有参与通信的设备地址不进行学习，笔者认为这是很节约信道资源的方案。
### 3.3.3 函数实现

```c
char* add_code_node(char* p);//插入源地址
int get_decode_node(char* s);//获得源地址
void reverse_addr_learn(int addr, int port);//反向地址学习
```
### 3.3.4 测试
- 初始MAC表为空
![反向地址学习测试](https://img-blog.csdnimg.cn/20200202110844128.png)
- 反向地址学习得到新的MAC表
![反向地址学习测试](https://img-blog.csdnimg.cn/20200202110903167.png)
## 3.4 未知广播
### 3.4.1 定义
交换机对未知目的地址的帧会广播到其他所有端口。	
问题：在由交换机组成的环状拓扑中，对于未知广播会引起广播风暴（广播数据充斥网络无法处理，并占用大量网络带宽，导致正常业务不能运行，甚至彻底瘫痪）。
### 3.4.2 方案
对于未知广播的转发处理代码实现较简单，不再赘述，笔者主要对其产生的广播风暴问题进行探讨：为交换机的每个端口设置设能标志，当出现广播风暴是，交换机会进行判决，使得其中一个端口逻辑上断开（即达到简单的生成树协议效果）。
### 3.4.3 代码实现

```c
bool disabled_0 = false;//定义使能标志：true为断开，false为正常连接
if (D_n > Max_Device && D_n != 15)//根据具体代码的端口断开条件
{
	……
	disabled_0 = true;// 接口 0断开
	printf("\n未知广播:%s\n设备 %d 物理层接口 0 断开！\n", my_initial_frame, Source_Device_number);
	continue;
}
//接口失效的具体实现方式
if (disabled_0)
{
	continue;
}

```
### 3.4.4 测试
- 1号网元向设备5发了信息，但在三个网元成环的测试案例中并不存在5号设备
![未知广播测试](https://img-blog.csdnimg.cn/20200202111239599.png)
- 与1号网元所连交换机为了避免广播风暴，做出断开接口的决策
![未知广播测试](https://img-blog.csdnimg.cn/2020020211130177.png)
## 3.5 交换机成环
### 3.5.1 概述
本例为仿真三个相连成环状的网元，各网元均为二层交换机。本例中使用了共享中所述简单的生成树协议，避免了广播风暴的发生。
### 3.5.2 拓扑图
![交换机成环拓扑图](https://img-blog.csdnimg.cn/20200202115518905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4ODk1OA==,size_16,color_FFFFFF,t_70)
## 3.6 心得体会
由于对套接字的不熟悉导致阶段二花费了大量的时间，交换机这块其实有挺多想法的，时间都耗完了，只是完成了基本功能。

